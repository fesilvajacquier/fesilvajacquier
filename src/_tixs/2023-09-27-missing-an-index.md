---
layout: post
title: missing an index
date: 2023-07-21
category: til
---

## Origin (context)

My error tracker (that has a perfomance module) reported a slow DB query.

It looked like this:

```sql
SELECT 1 AS one FROM "users" WHERE LOWER("users"."email") = LOWER('pirulo@mail.com') AND "users"."account_id" = 1 LIMIT 1
```

But wait, I have an index for that (`index_users_on_email_and_account_id`). How come it is an expensive query?

## Exploration journey

First things first, where is that query coming from?

After some digging in the logs I found that the query was generated by a validation:

```ruby
  validates :email, uniqueness: { case_sensitive: false, scope: :account_id }
```

After doing some reasearch (aka: searching in the interwebs) I found that when using the `LOWER` function in the `WHERE` clause a regular index will not trigger an index scan.

## Result

So, missing the index could be read as:

- not hitting the existing index.
- not having an index with an expression.

Although having not applied all of them, I found some possible solutions.

A cheap one: to normalize the email in a `before_validation` and remove the `case_sensitive` option from the validation.

Some expensive ones:

- change the column type to `citext`
- add an expression index

## Links

- [Rails Github -Related Issue](https://github.com/rails/rails/issues/47769)
- [BigBinary - Expression Index Post](https://www.bigbinary.com/blog/rails-5-adds-support-for-expression-indexes-for-postgresql)
- [Stackoverflow - Functions & Indexes](https://stackoverflow.com/questions/37927069/why-do-functions-on-columns-prevent-the-use-of-indexes)
